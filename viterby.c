/********************************************************************************
* @file    coder.c
* @author  Pospelova
* @version V1.0.0
* @date    March-2017
  ******************************************************************************
  * @attention
  *	Файл описывает реализацию сверточного декодирования по алгоритму Витерби.
  * Суть алгоритма заключается в следующем: если значение текущей последовательности
  * не совпадает с кодовым значением, соответствующим текущему состоянию конечного автомата,
  * то создается путь, в который помещается значение текущего узла (т.е. значение текущего состояния).
  *  Для несовпадающей последовательности строится набор из альтернативных путей, которые
  *  рано или поздно сойдутся при наступлении того или иного состояния. Для каждого пути
  *  подсчитывается метрика Хэмминга. Как только пути сошлись, они сравниваются по их
  *  соответствующим метрикам. Путь с наименьшей метрикой выживает и считается наиболее
  *  правдоподобным. Остальные пути отбрасываются. Чтобы алгоритм работал более эффективно,
  *  выбирается глубина поиска (т.е. ограничивается количество простраиваемых путей).
  *  Чаще всего глубина поиска берется равной 10, но при желании ее можно изменить
  *  (см. макрос DEPTH в заголовочном файле)
  ******************************************************************************
*/

#include "viterby.h"
#include <malloc.h>

/**
 * @brief функция запускает декодирование слова по алгоритму Витерби
 * @param
 *  codeWord - массив кодовых символов
 *  codeWordSize - размер мдекодированный массив
 *  decodeWordSize - размер выходного декодированного массива
 *  decodeWord - декодированное слово
 */
void getDecode(unsigned int *codeWord, unsigned int codeWordSize,
               unsigned int *decodeWord, unsigned int decodeWordSize)
{
    splitWord(codeWord, codeWordSize, NSequences, &NSize);  //разбиение закодированного слова

    unsigned int NSIndex = 0;   //инициализация итератора массива последовательностей из N символов
    sPath path[S];              //массив, хранящий в себевсе возможные пути до узла назначения
    unsigned int pathSize;      //размер массива path
    unsigned int depth;         //глубина поиска
    bool visit = false;         //флаг, отмечающий посещенный узел дерева путей
    bool isFirst = true;        //флаг, отмещающий, что дерево путей создано впервые

    unsigned int chSize = codeWordSize/2;   //размер массива с узлами наиболее вероятного пути
    unsigned int checked[chSize];           //массив, содержащий узлы наиболее вероятного пути
    unsigned int index = 0;     //текущий индекс массива, содержащего наиболее вероятный путь

    while(NSIndex < NSize)      //пока NSIndex меньше размера  массива последовательностей из N символов
    {
        clearPath(path, pathSize+1);                                                //очищение массива путей
        pathSize = 0;                                                               //сброс размера массива путей
        depth = 0;                                                                  //сброс глубины поиска
        pathTree = viterby(pathTree, &NSIndex, &depth);                             //вызов функции, реализующей алгоритм Витерби

        getPaths(pathTree, path, &pathSize, &visit, &isFirst);                      //получение массива вероятных путей
        isFirst = false;                                                            //сброс флага, так как дерево путей уже было создано

        unsigned int lastNode = checkPath(checked, chSize, &index, path, pathSize); //выбор наиболее оптимального пути. Переменная lastNode хранит последний пройденный узел выбранного пути
        removeTree(pathTree);                                                       //удаление дерева путей
        pathTree = NULL;                                                            //установка указателя на дерево путей в NULL
        pathTree = addNode(lastNode, NSIndex, pathTree, true);                      //добавление в дерево путей последнего пройденного узла (lastNode)
    }

    decode(decodeWord, decodeWordSize, checked, chSize);    //декодирование последовательности символов на основании полученного пути
}

/**
 * @brief фкнуция получения вероятных путей по алгоритму Витерби.
 * @param
 *  tree - указатель на текущий узел дерева возможных путей
 *  NSInd - текущий индекс массива последовательносте из N-символов
 *  depth - глубина поиска
 */
sTree *viterby(sTree *tree, unsigned int *NSInd, unsigned int *depth)
{
    unsigned int counter = 0;               //инициализация счетчика количества несовпадений
    bool left = true;                       //логический флаг, который определяет, в какое поддерево добавится новый узел: в левое или в правое
    unsigned int state;                     //текущее состояние конечного автомата

    if(tree != NULL)                        //если дерево путей не пустое
    {
        state = tree->data;                 //установка начального состояния в значение последнего узла дерева
    }
    else                                    //иначе
    {
        state = 0;                          //установка начального состояния в 0
    }

    if(*depth < DEPTH)                  //если текущая глубина поиска меньше максимально допустимой величины DEPTH
    {
        int j;                          //итератор по таблице переходов конечного автомата
        for(j = 0; j < S; j = j + 1)
        {
            if(jumpTable[state][j] > -1)                            //если значение перехода из текущего состояния state неотрицательное
            {
                unsigned int index = jumpTable[state][j];           //запись в index значения состояния, в которое возможен следующий переход

                if(arrCmp(NSequences[*NSInd], codeTable[index], N)) //если текущая последовательность совпадает с значением кодовой последовательности состояния index
                {
                    counter = 0;                                    //сброс счетчика
                    tree = addNode(index, *NSInd, tree, left);      //добавление в дерево путей значения переменной index
                    *depth = *depth + 1;                            //увеличение текущей глубины дерева на 1

                    *NSInd = *NSInd + 1;                            //переход к новой последовательности из N символов
                    break;                                          //выход из цикла
                }
                else                                                //иначе
                {
                    counter = counter + 1;                          //увеличение значения счетчика несовпадений
                    left = false;                                   //так как первая последовательность не совпала с текущей, то следующий узел уже не может быть добавлен в левое поддерево

                    if(counter == N)                                //если количество несовпадений равно N
                    {
                        counter = 0;                                //сброс счетчика

                        if(!tree)                                   //если дерево путей пустое
                        {
                            tree = addNode(index, *NSInd, tree, true);                      //добавить в дерево 1
                            *depth = *depth + 1;                                        //увеличение текущей глубины дерева
                            hammingCounter(tree, NSequences[*NSInd], codeTable[index]); //подсчет метрики Хэмминга для текущего узла

                            *NSInd = *NSInd + 1;                    //перехорд к следующей последовательности из N символов
                            viterby(tree, NSInd, depth);            //рекурсивный вызов функции для текущего дерева путей
                        }
                        else                                        //иначе
                        {
                            tree = addNode(index, *NSInd, tree, false);                                 //добавить в правое поддерево значение index
                            *depth = *depth + 1;                                                        //увеличить текущую глубину дерева
                            hammingCounter((sTree*)tree->right, NSequences[*NSInd], codeTable[index]);  //подсчет метрики Хэмминга для текущего узла дерева путей

                            index = jumpTable[state][j - 1];                                            //запись в переменную index значения предыдущего состояния (так как в этом состоянии последовательности также не совпали)
                            tree = addNode(index, *NSInd, tree, true);                                  //добавить в левое поддерево значение index
                            hammingCounter((sTree*)tree->left, NSequences[*NSInd], codeTable[index]);

                            *NSInd = *NSInd + 1;                            //переход к ледующей последовательности из N символов
                            viterby((sTree*)tree->right, NSInd, depth);     //рекурсивный вызов функции для правого поддерева


                            sTree *tmp = (sTree*)tree->left;                //запись в указатель tmp указателя на левое поддерево
                            *NSInd = tmp->codeIndex;                        //установка идекса массива последовательностей в точку ветвления дерева
                            *NSInd = *NSInd + 1;                            //переход к следющему элементу массива последовательностей
                            viterby((sTree*)tree->left, NSInd, depth);      //рекурсивный вызов функции для левого поддерева
                        }
                        break;                                              //выход из цикла
                    }
                }
            }
        }
    }
    return tree;
}

/**
 * @brief функция, очищающая массив вероятных путей
 * @param
 *  sPath path[S] - массив верочтных путей
 *  pathSize - размер массива вероятныз путей
 */
void clearPath(sPath path[S], unsigned int pathSize)
{
    unsigned  int i;                    //инициализация итератора по массиву вероятных путей
    for(i = 0; i < pathSize; i = i + 1)
    {
        path[i].metric = 0;             //сброс метрики текущего пути
        unsigned  int j;                //итератор по массиву пройденных узлов
        for(j = 0; j < path[i].nodeSize; j = j + 1)
        {
            path[i].currentNode[j] = 0; //сброс текущего пройденного узла
        }
        path[i].nodeSize = 0;           //сброс размера массива пройденных узлов
    }
}

/**
 * @brief фкнуция подсчета метрики Хэмминга.
 *        Метрика Хэмминга рассчитывается как количество
 *        различающихся символов в двух массивах.
 * @param
 *  tree - указатель на текущий узел дерева путей
 *  array_1 - указатель на первый массив
 *  array_2 - указатель на второй массив
 */
void hammingCounter(sTree *tree, unsigned int *array_1, unsigned int *array_2)
{
    int i;              //итератор
    int counter = 0;    //инициализация счетчика
    for(i = 0; i < N; i = i + 1)
    {
        if(array_1[i] != array_2[i])    //если символ массива 1 не равен символу массива 2
        {
            counter = counter + 1;      //увеличение счетчика
        }
    }
    tree->metric = counter;             //запись полученной метрики в текущий узел дерева путей
}

/**
 * @brief функция разбивает слово на массив последовательностей
 *        из N символов
 * @param
 *  word - разбиваемое слово
 *  wordSize - размер разбиваемого слова
 *  split - массив получившихся последовательностей из N-символов
 *  splitSize - размер массива последовательностей из N-символов
 */
void splitWord(unsigned int *word, unsigned int wordSize,
               unsigned int split[S][N], unsigned int *splitSize)
{
    unsigned int i;         //итератор по закодированному слову
    unsigned int k = 0;     //итератор по массиву последовательностей из N символов
    unsigned int j = 0;     //итератор по текущей последовательности из N символов
    for(i = 0; i < wordSize; i = i + 1)
    {
        split[k][j] =  word[i]; //запись в текущую последовательность текущего символа исходного слова
        j = j + 1;              //увеличение итератора
        if(j == N)              //если итератор равен N
        {
            j = 0;              //сброс итератора по текущей последовательности из N символов
            k = k + 1;          //увеличение итератора по массиву последовательностей из N символов
        }
    }
    *splitSize = k;             //запись в переменную размера массива последовательностей значения итератора k
}

/**
 * @brief Функция возвращает индекс наиболее вероятного пути
 * @param
 *  size - размер массива
 *  path - массив вероятных путей
 */
unsigned int getMin(sPath path[S], unsigned int size)
{
    unsigned int min = path[0].metric;  //инициализация минимальной метрики пути значением метрики первого пути
    unsigned int index = 0;             //индекс оптимального ути
    unsigned int i;                     //итератор по массиву вероятных путей
    for(i = 0; i < size; i = i + 1)
    {
        if(path[i].metric < min)        //если метрика текущего пути меньше минимальной
        {
            min = path[i].metric;       //переопределение минимальной метрики метрикой текущего пути
            index = i;                  //присвоение индексу опитмального пути интекса текущего пути
        }
    }
    return index;                       //вернуть индекс оптимального пути
}

/**
 * @brief функция добавляет в дерево вероятных путей новый узел
 * @param
 *  data - значение нового узла дерева
 *  codeIndex - индекс массива последовательностей, при котором произошло ветвление
 *  node - указатель на новый узел дерева
 *  left -  флаг, указывающий, в какое поддерево будет добавлен нвый узел.
 *          При left = true узел будет добавлен в левое поддерево, иначе - в правое.
 */
sTree *addNode(unsigned int data, unsigned int codeIndex,
               sTree *node, bool left)
{
    if(!node)                                   //если указатель на узел равен NULL
    {
        node = (sTree*) malloc(sizeof(sTree));  //выделяем память под указатель
        node->data = data;                      //запись значения узла
        node->metric = 0;                       //инициализация значения метрики узла
        node->codeIndex = codeIndex;            //запись индекса ветвления узла
        node->left = NULL;                      //инициализация указателя на левое поддерево узла
        node->right = NULL;                     //инициализация указателя на правое поддерево узла
        node->parent = NULL;                    //инициализация указателя на родительский узел
    }
    else                                        //иначе
    {
        if(left)                                //если left = true
        {
            node->left = createBranch(data, codeIndex, (sTree*)node->left, node, left);     //создание левого поддерева
        }
        else                                    //иначе
        {
            node->right = createBranch(data, codeIndex, (sTree*)node->right, node, left);   //создание правого поддерева
        }
    }
    return node;
}

/**
 * @brief функция добавляет в поддерево вероятных путей новый узел
 * @param
 *  data - значение нового узла дерева
 *  codeIndex - индекс массива последовательностей, при котором произошло ветвление
 *  node - указатель на новый узел дерева
 *  left -  флаг, указывающий, в какое поддерево будет добавлен нвый узел.
 *  parent - указатель на родительский узел
 */
sTree * createBranch(unsigned int data, unsigned int codeIndex,
                     sTree *node, sTree *parent, bool left)
{
    node = addNode(data, codeIndex, node, left);    //добавление нового узла в поддерево
    node->parent = parent;                          //добавление указателя на родительский узел
    return node;
}

/**
 * @brief Функция удаляет дерево
 * @param
 *  tree - указатель на дерево
 */
void removeTree(sTree *tree)
{
    if(!tree)                               //пока существует указатель на дерево
    {
        removeTree((sTree*)tree->left);     //удаление левого поддерева
        removeTree((sTree*)tree->right);    //удаление правого поддерева
        free(tree);                         //освобождние памяти текущего указателя на дерево
    }
}

/**
 * @brief Функция проверяет полученный массив путей и выбирает из него наиболее оптимальный.
 *        Также функция возвращает последний посещенный узел наиболее вероятного пути
 * @param
 *  checked - указатель на массив, куда будет записана проверенная последовательность символов
 *  checkedSize - размер этого массива
 *  chIndex - указательн на текущий индекс этого массива
 *  path - массив вероятных путей
 *  pathSize - размер массива вероятных путей
 */
int checkPath(unsigned int *checked, unsigned int checkedSize, unsigned int *chIndex,
              sPath path[S], unsigned int pathSize)
{
    unsigned int min = getMin(path, pathSize);      //получение индекса пути с минимальной метрикой (т.е. индекса наиболее вероятного пути)
    unsigned int i;                                 //итератор по узлам наиболее ветоятного пути
    for(i = 0; i < path[min].nodeSize; i = i + 1)
    {
        checked[*chIndex] = path[min].currentNode[i];   //добавление в массив наиболее вероятного пути
        *chIndex = *chIndex + 1;                        //увеличение индекса массива наиболее вероятного пути
        if(*chIndex > checkedSize - 1)                  //если индекс превышает размер массива
        {
            break;                                      //выход из цикла
        }
    }
    unsigned int lastNode = path[min].currentNode[path[min].nodeSize - 1];  //запись в переменную lastNode значения последнего посещенного узла
    return lastNode;
}

/**
 * @brief Функция анализирует дерево путей и строит на его основе массив вероятных путей
 * @param
 *  tree - указатель на дерево возможных путей
 *  path - массив путей
 *  size - размер массива путей
 *  visit - флаг посещения узла
 *  isFirst - флаг первого посещения дерева
 */
void getPaths(sTree *tree, sPath path[S], unsigned int *size,
              bool *visit, bool *isFirst)
{
    if(!tree->parent && !tree->left && !tree->right)    //если дерево содержит в себе один узел
    {
        appendValue(path, *size, tree);     //добавление в массив путей узла дерева
        return;                             //выход из функции
    }
    else if(tree->parent)                   //если у текущего узла существует родитель
    {
        appendValue(path, *size, tree);     //добавление в массив путей узла дерева
    }
    else if(*isFirst)                       //если дерево псещается впервые
    {
        appendValue(path, *size, tree);     //добавление в массив путей узла дерева
        *isFirst = false;                   //сброс флага
    }

    if(tree->left)                                                  //если существует указатель на левое поддерево
    {
        *visit = true;                                              //отмечаем узел посещенным
        getPaths((sTree*)tree->left, path, size, visit, isFirst);   //рекурсивный вызов функции для левого поддерева
    }
    if(tree->right)                                                 //если существует указатель на правое поддерево
    {
        if(!*visit)                                                 //если текущий узел не посещался
        {
            if(tree->parent)                                        //если существует указатель на родительский узел
            {
                appendValue(path, *size, tree);                     //добавление в массив путей узла дерева
            }
        }
        *visit = true;                                              //отмечаем узел посещенным
        getPaths((sTree*)tree->right, path, size, visit, isFirst);  //рекурсивный вызов функции для правого поддерева
    }
    else
    {
        if(*visit)                                                  //если узел был посещен
        {
            *size = *size + 1;                                      //увеличение индекса массива путей
            *visit = false;                                         //сброс флага посещения узла
        }
    }
}

/**
 * @brief Функция добавляет в массив путей новое значение
 * @param
 *  path - массив путей
 *  size - текущий размер массива путей
 *  value - указатель на соответствующий узер дерева путей
 */
void appendValue(sPath path[S], unsigned int size, sTree *value)
{
    int i = path[size].nodeSize;                            //индекс текущего узла для текущего массива путей
    path[size].metric = path[size].metric + value->metric;  //суммирование текущей метрики пути с метрикой добавляемого узла
    path[size].currentNode[i] = value->data;                //добавление в путь значения нового узла
    path[size].nodeSize = path[size].nodeSize + 1;          //увеличение количества узлов пути
}

/**
 * @brief Функция декодирует выходное слово на основании полученного
 *        наиболее оптимального пути
 * @param
 *  decodeWord - указатель на массив декодированных символов
 *  decodeWordSize - размер массива декодированных символов
 *  checkedPath - указатель на массив узлов наиболее оптимального пути
 *  chSize - размер массива узлов наиболее оптимального пути
 */
void decode(unsigned int *decodeWord, unsigned int decodeWordSize, unsigned int *checkedPath, unsigned int chSize)
{
    int j = decodeWordSize - 1;     //инициализация итератора по декодированному слову. Так как декодирование происходит в обратном порядке, то итературу присваивается последний индекс слова
    for(unsigned int i = 0; i < chSize; ++i)
    {
        int index = checkedPath[i]; //запись в переменную index значения текущего узла массива путей
        decodeWord[j] = stateTable[index][0];   //запись в массив декодированных символов нового элемента
        --j;                        //декремент индекса массива декодированных символов
        if(j < 0)                   //если декремент меньше нуля
        {
            break;                  //выход из цикла
        }
    }
}

